name: üöÄ Crear Backlog y Sprints - BrainBlitz Vision Computacional

on:
  workflow_dispatch: # Permite ejecutar este workflow manualmente desde la pesta√±a Actions

# Define el token con permisos de escritura
permissions:
  contents: write # ‚ö†Ô∏è Se cambi√≥ a 'write' para poder crear ramas
  issues: write
  # Es necesario a√±adir permisos para 'pull-requests: write' para que pueda crear etiquetas
  pull-requests: write

jobs:
  setup-project-backlog:
    runs-on: ubuntu-latest
    steps:
      # PASO 1: Descarga el c√≥digo del repositorio
      - name: Checkout repository
        uses: actions/checkout@v4

      # PASO 2: Crea el proyecto si no existe y obtiene su n√∫mero autom√°ticamente
      - name: Crear Proyecto de GitHub si no existe
        id: project_setup # Le damos un ID a este paso para usar sus resultados
        env:
          # ‚ö†Ô∏è MODIFICACI√ìN A√ëADIDA: Usa el Token de Acceso Personal para tener permisos
          GITHUB_TOKEN: ${{ secrets.GH_PAT }}
        run: |
          PROJECT_NAME="BrainBlitz - Computer Vision Backlog"
          # ‚ö†Ô∏è MODIFICACI√ìN A√ëADIDA: Comando corregido para buscar el proyecto
          PROJECT_NUMBER=$(gh project list --owner "@me" --format json | jq -r ".projects[] | select(.title == \"$PROJECT_NAME\") | .number")
          
          if [ -z "$PROJECT_NUMBER" ]; then
            echo "Proyecto '$PROJECT_NAME' no encontrado. Cre√°ndolo ahora..."
            # Crea el proyecto y extrae su n√∫mero de la URL resultante
            PROJECT_URL=$(gh project create --owner "@me" --title "$PROJECT_NAME")
            PROJECT_NUMBER=$(echo "$PROJECT_URL" | rev | cut -d'/' -f1 | rev)
            echo "Proyecto creado con el n√∫mero: $PROJECT_NUMBER"
          else
            echo "Proyecto '$PROJECT_NAME' ya existe con el n√∫mero: $PROJECT_NUMBER"
          fi
          # Guarda el n√∫mero del proyecto para que otros pasos puedan usarlo
          echo "PROJECT_NUMBER=$PROJECT_NUMBER" >> $GITHUB_OUTPUT

      # PASO 3: Crea las Etiquetas de Prioridad y Tecnolog√≠a si no existen
      - name: Crear Etiquetas si no existen
        env:
          GITHUB_TOKEN: ${{ secrets.GH_PAT }} # Usamos el PAT para consistencia
        run: |
          echo "Creando etiquetas de prioridad..."
          gh label create "Prioridad: Alta" --color "D93F0B" --description "Tarea cr√≠tica y bloqueante." || echo "La etiqueta 'Prioridad: Alta' ya existe."
          gh label create "Prioridad: Media" --color "FBCA04" --description "Tarea importante pero no urgente." || echo "La etiqueta 'Prioridad: Media' ya existe."
          gh label create "Prioridad: Baja" --color "0E8A16" --description "Tarea menor o mejora deseable." || echo "La etiqueta 'Prioridad: Baja' ya existe."
          
          echo "Creando etiquetas de tecnolog√≠a..."
          gh label create "Tecnolog√≠a: Azure" --color "0078D4" --description "Usa servicios de Azure" || echo "La etiqueta 'Tecnolog√≠a: Azure' ya existe."
          gh label create "Tecnolog√≠a: DeepFace" --color "6F42C1" --description "Usa DeepFace para reconocimiento facial" || echo "La etiqueta 'Tecnolog√≠a: DeepFace' ya existe."
          gh label create "Tecnolog√≠a: Firebase" --color "FF6D01" --description "Integraci√≥n con Firebase" || echo "La etiqueta 'Tecnolog√≠a: Firebase' ya existe."
          gh label create "IA: Visi√≥n Computacional" --color "00B294" --description "Implementa visi√≥n computacional" || echo "La etiqueta 'IA: Visi√≥n Computacional' ya existe."

      # PASO 4: Crea los Milestones (Sprints) solo si no existen
      - name: Crear Milestones si no existen
        env:
          GITHUB_TOKEN: ${{ secrets.GH_PAT }} # Usamos el PAT para consistencia
          GH_REPO: ${{ github.repository }}
        run: |
          # --- Sprint 1: Autenticaci√≥n y Extracci√≥n ---
          MILESTONE_SPRINT1_TITLE="Sprint 1: Autenticaci√≥n y Extracci√≥n (17-19 Noviembre)"
          if gh api /repos/${GH_REPO}/milestones --paginate -q ".[] | select(.title == \"$MILESTONE_SPRINT1_TITLE\")" | grep -qF "$MILESTONE_SPRINT1_TITLE"; then
            echo "Milestone '$MILESTONE_SPRINT1_TITLE' ya existe. Omitiendo."
          else
            echo "Creando milestone '$MILESTONE_SPRINT1_TITLE'..."
            gh api --method POST -H "Accept: application/vnd.github+json" "/repos/${GH_REPO}/milestones" \
              -f title="$MILESTONE_SPRINT1_TITLE" \
              -f description='Implementar OCR y Reconocimiento Facial. Total: 21 Story Points' \
              -f due_on='2025-11-19T23:59:59Z'
          fi

          # --- Sprint 2: An√°lisis Visual Avanzado ---
          MILESTONE_SPRINT2_TITLE="Sprint 2: An√°lisis Visual Avanzado (20-24 Noviembre)"
          if gh api /repos/${GH_REPO}/milestones --paginate -q ".[] | select(.title == \"$MILESTONE_SPRINT2_TITLE\")" | grep -qF "$MILESTONE_SPRINT2_TITLE"; then
            echo "Milestone '$MILESTONE_SPRINT2_TITLE' ya existe. Omitiendo."
          else
            echo "Creando milestone '$MILESTONE_SPRINT2_TITLE'..."
            gh api --method POST -H "Accept: application/vnd.github+json" "/repos/${GH_REPO}/milestones" \
              -f title="$MILESTONE_SPRINT2_TITLE" \
              -f description='Implementar an√°lisis de im√°genes y detecci√≥n de objetos. Total: 20 Story Points' \
              -f due_on='2025-11-24T23:59:59Z'
          fi

      # PASO 5: Configurar el proyecto con campos necesarios
      - name: Configurar Campos del Proyecto
        env:
          GITHUB_TOKEN: ${{ secrets.GH_PAT }}
          PROJECT_NUMBER: ${{ steps.project_setup.outputs.PROJECT_NUMBER }}
        run: |
          echo "‚öôÔ∏è Configurando campos del proyecto..."
          PROJECT_ID=$(gh project view ${{ env.PROJECT_NUMBER }} --owner "@me" --format json | jq -r '.id')
          
          # Verificar si existe el campo Status
          echo "üîç Buscando campo Status..."
          STATUS_FIELD_ID=$(gh api graphql -f query='
            query($projectId: ID!) {
              node(id: $projectId) {
                ... on ProjectV2 {
                  fields(first: 20) {
                    nodes {
                      ... on ProjectV2Field {
                        id
                        name
                      }
                      ... on ProjectV2SingleSelectField {
                        id
                        name
                        options {
                          id
                          name
                        }
                      }
                    }
                  }
                }
              }
            }
          ' -f projectId="$PROJECT_ID" | jq -r '.data.node.fields.nodes[] | select(.name == "Status") | .id')
          
          if [ -z "$STATUS_FIELD_ID" ] || [ "$STATUS_FIELD_ID" = "null" ]; then
            echo "üÜï Creando campo Status..."
            # Crear campo single select para Status
            STATUS_FIELD_ID=$(gh api graphql -f query='
              mutation($projectId: ID!) {
                addProjectV2FieldById(input: {
                  projectId: $projectId
                  fieldType: SINGLE_SELECT
                  name: "Status"
                  dataType: SINGLE_SELECT
                  singleSelectOptions: [
                    { name: "Todo", color: BLUE }
                    { name: "In Progress", color: YELLOW }
                    { name: "Done", color: GREEN }
                  ]
                }) {
                  projectV2Field {
                    id
                    name
                  }
                }
              }
            ' -f projectId="$PROJECT_ID" | jq -r '.data.addProjectV2FieldById.projectV2Field.id')
            
            echo "‚úÖ Campo Status creado con ID: $STATUS_FIELD_ID"
          else
            echo "‚úÖ Campo Status ya existe: $STATUS_FIELD_ID"
          fi
          
          # Obtener el ID de la opci√≥n "Todo"
          TODO_COLUMN_ID=$(gh api graphql -f query='
            query($projectId: ID!) {
              node(id: $projectId) {
                ... on ProjectV2 {
                  fields(first: 20) {
                    nodes {
                      ... on ProjectV2SingleSelectField {
                        id
                        name
                        options {
                          id
                          name
                        }
                      }
                    }
                  }
                }
              }
            }
          ' -f projectId="$PROJECT_ID" | jq -r '.data.node.fields.nodes[] | select(.name == "Status") | .options[] | select(.name == "Todo") | .id')
          
          echo "üìã ID de opci√≥n Todo: $TODO_COLUMN_ID"
          
          # Guardar los IDs para el siguiente paso
          echo "STATUS_FIELD_ID=$STATUS_FIELD_ID" >> $GITHUB_ENV
          echo "TODO_COLUMN_ID=$TODO_COLUMN_ID" >> $GITHUB_ENV
          echo "PROJECT_ID=$PROJECT_ID" >> $GITHUB_ENV

      # PASO 6: Crear Iterations (Fechas de Iteraci√≥n) en el Project
      - name: Crear Iterations en el Proyecto
        env:
          GITHUB_TOKEN: ${{ secrets.GH_PAT }}
          PROJECT_NUMBER: ${{ steps.project_setup.outputs.PROJECT_NUMBER }}
          PROJECT_ID: ${{ env.PROJECT_ID }}
        run: |
          echo "üîÑ Creando iterations en el proyecto..."
          
          # Verificar si existe el campo Iteration
          echo "üîç Buscando campo Iteration..."
          ITERATION_FIELD_ID=$(gh api graphql -f query='
            query($projectId: ID!) {
              node(id: $projectId) {
                ... on ProjectV2 {
                  fields(first: 20) {
                    nodes {
                      ... on ProjectV2Field {
                        id
                        name
                      }
                      ... on ProjectV2IterationField {
                        id
                        name
                      }
                    }
                  }
                }
              }
            }
          ' -f projectId="$PROJECT_ID" | jq -r '.data.node.fields.nodes[] | select(.name == "Iteration") | .id')
          
          if [ -z "$ITERATION_FIELD_ID" ] || [ "$ITERATION_FIELD_ID" = "null" ]; then
            echo "üÜï Creando campo Iteration..."
            # Crear campo iteration
            ITERATION_FIELD_ID=$(gh api graphql -f query='
              mutation($projectId: ID!) {
                addProjectV2FieldById(input: {
                  projectId: $projectId
                  fieldType: ITERATION
                  name: "Iteration"
                }) {
                  projectV2Field {
                    id
                    name
                  }
                }
              }
            ' -f projectId="$PROJECT_ID" | jq -r '.data.addProjectV2FieldById.projectV2Field.id')
            echo "‚úÖ Campo Iteration creado con ID: $ITERATION_FIELD_ID"
          else
            echo "‚úÖ Campo Iteration ya existe: $ITERATION_FIELD_ID"
          fi

          # Funci√≥n para crear iteration
          create_iteration() {
            local title="$1"
            local start_date="$2"
            local end_date="$3"
            
            echo "üîç Verificando iteration: $title"
            
            # Verificar si la iteration ya existe
            EXISTING_ITERATION=$(gh api graphql -f query='
              query($projectId: ID!) {
                node(id: $projectId) {
                  ... on ProjectV2 {
                    fields(first: 20) {
                      nodes {
                        ... on ProjectV2IterationField {
                          id
                          name
                          configuration {
                            iterations {
                              id
                              title
                              startDate
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            ' -f projectId="$PROJECT_ID" | jq -r ".data.node.fields.nodes[] | select(.name == \"Iteration\") | .configuration.iterations[] | select(.title == \"$title\") | .id")
            
            if [ -n "$EXISTING_ITERATION" ] && [ "$EXISTING_ITERATION" != "null" ]; then
              echo "‚úÖ Iteration '$title' ya existe: $EXISTING_ITERATION"
              echo "$EXISTING_ITERATION"
              return
            fi
            
            # Crear la iteration
            echo "üÜï Creando iteration: $title"
            ITERATION_RESULT=$(gh api graphql -f query='
              mutation($projectId: ID!, $title: String!, $startDate: Date!) {
                createProjectV2Iteration(input: {
                  projectId: $projectId
                  title: $title
                  startDate: $startDate
                  duration: 2
                }) {
                  iteration {
                    id
                    title
                    startDate
                    duration
                  }
                }
              }
            ' -f projectId="$PROJECT_ID" -f title="$title" -f startDate="$start_date" 2>/dev/null || echo "")
            
            if [ -n "$ITERATION_RESULT" ]; then
              ITERATION_ID=$(echo "$ITERATION_RESULT" | jq -r '.data.createProjectV2Iteration.iteration.id' 2>/dev/null || echo "")
              if [ -n "$ITERATION_ID" ] && [ "$ITERATION_ID" != "null" ]; then
                echo "‚úÖ Iteration creada: $title - ID: $ITERATION_ID"
                echo "$ITERATION_ID"
              else
                echo "‚ö†Ô∏è No se pudo crear iteration: $title"
                echo ""
              fi
            else
              echo "‚ö†Ô∏è No se pudo crear iteration: $title"
              echo ""
            fi
          }

          # Crear iterations para los sprints
          SPRINT1_ITERATION_ID=$(create_iteration "Sprint 1: 17-19 Nov" "2025-11-17")
          SPRINT2_ITERATION_ID=$(create_iteration "Sprint 2: 20-24 Nov" "2025-11-20")
          
          # Guardar los IDs para el siguiente paso
          echo "SPRINT1_ITERATION_ID=$SPRINT1_ITERATION_ID" >> $GITHUB_ENV
          echo "SPRINT2_ITERATION_ID=$SPRINT2_ITERATION_ID" >> $GITHUB_ENV
          echo "ITERATION_FIELD_ID=$ITERATION_FIELD_ID" >> $GITHUB_ENV

      # PASO 7: Crea todos los Issues, los a√±ade al proyecto y solo si no existen
      - name: Crear Issues y a√±adirlas al Proyecto
        env:
          GITHUB_TOKEN: ${{ secrets.GH_PAT }} # Usamos el PAT para consistencia
          PROJECT_NUMBER: ${{ steps.project_setup.outputs.PROJECT_NUMBER }}
          PROJECT_ID: ${{ env.PROJECT_ID }}
          STATUS_FIELD_ID: ${{ env.STATUS_FIELD_ID }}
          TODO_COLUMN_ID: ${{ env.TODO_COLUMN_ID }}
          ITERATION_FIELD_ID: ${{ env.ITERATION_FIELD_ID }}
          SPRINT1_ITERATION_ID: ${{ env.SPRINT1_ITERATION_ID }}
          SPRINT2_ITERATION_ID: ${{ env.SPRINT2_ITERATION_ID }}
        run: |
          echo "üìù Creando issues de visi√≥n computacional..."
          echo "IDs disponibles:"
          echo "PROJECT_ID: $PROJECT_ID"
          echo "STATUS_FIELD_ID: $STATUS_FIELD_ID"
          echo "TODO_COLUMN_ID: $TODO_COLUMN_ID"
          echo "ITERATION_FIELD_ID: $ITERATION_FIELD_ID"
          echo "SPRINT1_ITERATION_ID: $SPRINT1_ITERATION_ID"
          echo "SPRINT2_ITERATION_ID: $SPRINT2_ITERATION_ID"

          # La funci√≥n ahora tambi√©n a√±ade la issue al proyecto.
          create_and_add_to_project() {
            local title="$1"
            local body="$2"
            local label="$3"
            local milestone="$4"
            local iteration_id="$5"
            
            ISSUE_URL=$(gh issue list --state all --search "in:title \"$title\"" --json url -q ".[0].url")

            if [ -n "$ISSUE_URL" ]; then
              echo "Issue '$title' ya existe. Omitiendo creaci√≥n."
            else
              echo "Creando issue '$title'..."
              ISSUE_URL=$(gh issue create --title "$title" --body "$body" --label "$label" --milestone "$milestone")
            fi

            if [ -n "$ISSUE_URL" ]; then
                echo "A√±adiendo issue $ISSUE_URL al proyecto $PROJECT_NUMBER..."
                CONTENT_ID=$(gh issue view $ISSUE_URL --json id | jq -r '.id')

                # A√±ade la issue al proyecto y obtiene el ID del item
                ITEM_ID=$(gh api graphql -f query='
                  mutation($project:ID!, $content:ID!) {
                    addProjectV2ItemById(input: {projectId: $project, contentId: $content}) {
                      item { id }
                    }
                  }
                ' -f project="$PROJECT_ID" -f content="$CONTENT_ID" | jq -r '.data.addProjectV2ItemById.item.id')

                echo "üìã Item creado en proyecto: $ITEM_ID"

                # Mover a Todo si tenemos los IDs necesarios
                if [ -n "$STATUS_FIELD_ID" ] && [ -n "$TODO_COLUMN_ID" ] && [ -n "$ITEM_ID" ]; then
                  echo "üîÑ Moviendo issue a Todo..."
                  
                  gh api graphql -f query="
                    mutation {
                      updateProjectV2ItemFieldValue(input: {
                        projectId: \"$PROJECT_ID\",
                        itemId: \"$ITEM_ID\",
                        fieldId: \"$STATUS_FIELD_ID\",
                        value: {singleSelectOptionId: \"$TODO_COLUMN_ID\"}
                      }) {
                        projectV2Item { id }
                      }
                    }
                  " && echo "‚úÖ Issue movida a Todo" || echo "‚ö†Ô∏è No se pudo mover la issue a Todo"
                else
                  echo "‚ö†Ô∏è No se pudo mover la issue a Todo (IDs faltantes)"
                fi
                
                # Asignar iteration si existe el campo y se proporcion√≥ un ID de iteration
                if [ -n "$ITERATION_FIELD_ID" ] && [ -n "$iteration_id" ] && [ -n "$ITEM_ID" ]; then
                  echo "üìÖ Asignando iteration a la issue..."
                  gh api graphql -f query="
                    mutation {
                      updateProjectV2ItemFieldValue(input: {
                        projectId: \"$PROJECT_ID\",
                        itemId: \"$ITEM_ID\",
                        fieldId: \"$ITERATION_FIELD_ID\",
                        value: {iterationId: \"$iteration_id\"}
                      }) {
                        projectV2Item { id }
                      }
                    }
                  " && echo "‚úÖ Iteration asignada" || echo "‚ö†Ô∏è No se pudo asignar iteration"
                fi
            fi
          }

          # ===============================================
          # ==         ISSUES SPRINT 1                  ==
          # ===============================================

          create_and_add_to_project \
            "HU-VC2: [BE] OCR - Extracci√≥n de Texto de Im√°genes" \
            "**Como** usuario o administrador de BrainBlitz, **Quiero** poder extraer texto autom√°ticamente de im√°genes, **Para que** pueda generar preguntas de forma m√°s eficiente.

            ---
            ### **Puntos de Estimaci√≥n:** 8
            ---
            ### **Criterios de Aceptaci√≥n:**
            - ‚úÖ Configurar Azure Computer Vision con API Key y Endpoint
            - ‚úÖ Crear endpoint POST /api/vision/extract-text
            - ‚úÖ Integrar con Azure OCR v3.2 para procesamiento as√≠ncrono
            - ‚úÖ Desarrollar componente OCRQuestionCreator.jsx en frontend
            - ‚úÖ Permitir subida de im√°genes y preview
            - ‚úÖ Mostrar texto extra√≠do en textarea editable
            - ‚úÖ Integrar con AIQuestionGenerator.jsx
            - ‚úÖ Realizar pruebas con JPG, PNG, PDF

            ### **Tecnolog√≠as:**
            - Azure Computer Vision OCR
            - Node.js, Express, React
            - Base64 encoding

            ### **Dependencias:**
            - Configuraci√≥n de Azure Computer Vision
            - Variables: AZURE_COMPUTER_VISION_KEY, AZURE_COMPUTER_VISION_ENDPOINT" \
            "Prioridad: Media,IA: Visi√≥n Computacional,Tecnolog√≠a: Azure" "Sprint 1: Autenticaci√≥n y Extracci√≥n (17-19 Noviembre)" "$SPRINT1_ITERATION_ID"

          create_and_add_to_project \
            "HU-VC1: [BE] Reconocimiento Facial para Login y Registro" \
            "**Como** usuario de BrainBlitz, **Quiero** poder autenticarme usando reconocimiento facial, **Para que** tenga una experiencia m√°s segura y moderna.

            ---
            ### **Puntos de Estimaci√≥n:** 13
            ---
            ### **Criterios de Aceptaci√≥n:**
            - ‚úÖ Crear endpoints POST /api/face/register y POST /api/face/login
            - ‚úÖ Implementar validaci√≥n de rostros con DeepFace
            - ‚úÖ Generar embeddings faciales con modelo VGG-Face
            - ‚úÖ Almacenar embeddings en Firestore asociados a userId
            - ‚úÖ Desarrollar componentes FaceRegister.jsx y FaceLogin.jsx
            - ‚úÖ Integrar vista previa de c√°mara en tiempo real
            - ‚úÖ Configurar microservicio facial en Azure Container Instances
            - ‚úÖ Implementar rate limiting y seguridad
            - ‚úÖ Realizar pruebas de autenticaci√≥n biom√©trica

            ### **Tecnolog√≠as:**
            - DeepFace, VGG-Face
            - Azure Container Instances
            - Firebase Auth
            - React, getUserMedia API

            ### **Dependencias:**
            - Microservicio facial desplegado
            - Firebase Auth configurado
            - Azure Container Instances" \
            "Prioridad: Alta,IA: Visi√≥n Computacional,Tecnolog√≠a: DeepFace,Tecnolog√≠a: Firebase" "Sprint 1: Autenticaci√≥n y Extracci√≥n (17-19 Noviembre)" "$SPRINT1_ITERATION_ID"

          # ===============================================
          # ==         ISSUES SPRINT 2                  ==
          # ===============================================

          create_and_add_to_project \
            "HU-VC3: [BE] An√°lisis Inteligente de Im√°genes" \
            "**Como** usuario o administrador de BrainBlitz, **Quiero** analizar im√°genes autom√°ticamente, **Para que** pueda generar preguntas basadas en contenido visual.

            ---
            ### **Puntos de Estimaci√≥n:** 10
            ---
            ### **Criterios de Aceptaci√≥n:**
            - ‚úÖ Crear endpoint POST /api/vision/analyze-image
            - ‚úÖ Integrar con Azure Analyze Image API
            - ‚úÖ Extraer descripci√≥n, tags, categor√≠as, objetos y colores
            - ‚úÖ Ordenar resultados por confianza descendente
            - ‚úÖ Desarrollar componente ImageAnalysisQuestionCreator.jsx
            - ‚úÖ Mostrar resultados en secciones organizadas
            - ‚úÖ Implementar generaci√≥n autom√°tica de preguntas
            - ‚úÖ Pre-llenar formularios con sugerencias
            - ‚úÖ Realizar pruebas con diferentes tipos de im√°genes

            ### **Tecnolog√≠as:**
            - Azure Computer Vision Analyze Image
            - Node.js, Express, React

            ### **Dependencias:**
            - Azure Computer Vision configurado
            - Variables: AZURE_COMPUTER_VISION_KEY, AZURE_COMPUTER_VISION_ENDPOINT" \
            "Prioridad: Media,IA: Visi√≥n Computacional,Tecnolog√≠a: Azure" "Sprint 2: An√°lisis Visual Avanzado (20-24 Noviembre)" "$SPRINT2_ITERATION_ID"

          create_and_add_to_project \
            "HU-VC4: [BE] Detecci√≥n de Objetos en Im√°genes" \
            "**Como** usuario de BrainBlitz, **Quiero** detectar objetos en im√°genes, **Para que** pueda crear preguntas visuales interactivas.

            ---
            ### **Puntos de Estimaci√≥n:** 10
            ---
            ### **Criterios de Aceptaci√≥n:**
            - ‚úÖ Crear endpoint POST /api/vision/detect-objects
            - ‚úÖ Integrar con Azure Object Detection API
            - ‚úÖ Procesar bounding boxes y niveles de confianza
            - ‚úÖ Desarrollar componente ObjectDetectionQuestionCreator.jsx
            - ‚úÖ Mostrar bounding boxes sobre im√°genes
            - ‚úÖ Implementar funcionalidades interactivas (hover, filtros)
            - ‚úÖ Generar preguntas de identificaci√≥n y conteo autom√°ticamente
            - ‚úÖ Usar Canvas API para visualizaci√≥n
            - ‚úÖ Realizar pruebas de precisi√≥n y m√∫ltiples objetos

            ### **Tecnolog√≠as:**
            - Azure Computer Vision Object Detection
            - Node.js, Express, React
            - Canvas API

            ### **Dependencias:**
            - Azure Computer Vision configurado
            - Variables: AZURE_COMPUTER_VISION_KEY, AZURE_COMPUTER_VISION_ENDPOINT" \
            "Prioridad: Media,IA: Visi√≥n Computacional,Tecnolog√≠a: Azure" "Sprint 2: An√°lisis Visual Avanzado (20-24 Noviembre)" "$SPRINT2_ITERATION_ID"

      # PASO 8: Crea y Vincula las Ramas para cada Issue
      - name: Crear Ramas y Vincularlas a las Issues
        env:
          GITHUB_TOKEN: ${{ secrets.GH_PAT }} # Usamos el PAT para consistencia
        run: |
          MAIN_BRANCH_SHA=$(git rev-parse main)
          gh issue list --state open --json number,title | jq -c '.[]' | while read issue; do
            ISSUE_NUMBER=$(echo $issue | jq -r '.number')
            ISSUE_TITLE=$(echo $issue | jq -r '.title')
            BRANCH_TITLE=$(echo "$ISSUE_TITLE" | iconv -t ascii//TRANSLIT | sed -E 's/\[(BE|FE)\] //g' | sed -E 's/HU-VC[0-9]+: //g' | sed -E 's/[^a-zA-Z0-9]+/-/g' | sed -E 's/^-+\|-+$//g' | tr '[:upper:]' '[:lower:]')
            BRANCH_NAME="hu-vc${ISSUE_NUMBER}-${BRANCH_TITLE}"

            if git ls-remote --heads origin "$BRANCH_NAME" | grep -q "$BRANCH_NAME"; then
              echo "La rama '$BRANCH_NAME' ya existe."
            else
              echo "Creando rama '$BRANCH_NAME'..."
              gh api repos/${{ github.repository }}/git/refs --method POST -f ref="refs/heads/${BRANCH_NAME}" -f sha="$MAIN_BRANCH_SHA"
              # Comenta en la issue para vincular la rama
              gh issue comment $ISSUE_NUMBER --body "Se ha creado la rama de trabajo para esta HU de Visi√≥n Computacional: \`$BRANCH_NAME\`"
            fi
          done
